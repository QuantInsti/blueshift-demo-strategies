# Copyright 2022 QuantInsti Quantitative Learnings Pvt Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Created on Thu Sep 22 20:42:22 2022
@author: prodi
    Iceberg Execution Algorithm
    This implmenets the iceberg orders. An iceberg order takes in a 
    (large) target quantity to trade and then slice it up and places 
    the slices as smaller orders. If the number of slices does not 
    match the total quantity, any reminders is added to the order for 
    the last slice.
    
    The parameters are as below:
        
        - `asset`: The asset symbol for this order
        - `quantity`: Quantity for the whole order
        - `side`: Order side, either "buy" or "sell"
        - `slices`: Number of slices to divide this order
        - `price`: Limit price specification for the order
        - `price_method`: Method for calculating the limit price.
        - `product_type`: Product type - delivery or margin.
        - `delay`: Delay time between order slices (in minutes).
        
    If the order type is market, the order is simply split in number 
    of slices specified. An order for the first slice is placed 
    immediately. Orders for the next slice is placed only if the previous
    one is fully executed, after the specified delay. Limit orders works
    similarly, except all orders placed are limit orders. If the 
    `price_method` is "absolute", each order is placed at the same 
    limit price as specified by `price`. If the `price_method` is 
    "relative", each order is placed with the current price adjusted by 
    the amount specified in "price" in favour of the order side. The 
    parameters `price` and `price_method` together determines the 
    order type. If `price_method` is 'absolute`, a non-zero `price` 
    is a limit order, else it becomes market. If the `price_method` 
    is 'relative`, the order is always limit.
    
    .. note::
        There are two ways Blueshift will parse and understand this 
        strategy code. You can either define a single class in the 
        strategy module. In that case, you need to make sure the 
        algo type is saved in the class variable `algo` properly, as 
        well as the module name is also the same (e.g. iceberg.py).
        Alternatively, you can define a registry (a dict) at the end 
        of the module and register multiple classes by their `algo` 
        type. All strategy modules should be in a pre-defined location
        for Blueshift to discover them.
        
    .. note::
        The `algo_id` attribute is the exchange approval ID for the 
        algo. All orders generated by this algo will use this algo ID
        as the order `placed_by` property.
        
    .. important::
        You must handle possible errors in your strategy code. The 
        default error handling will continue to run the strategy if 
        the error is deemed recoverable (e.g. data query failure, or
        order placement failure), and will exit the strategy if it is 
        not recoverable (e.g. wrong asset symbol). To reflect 
        appropriate error handling, manage it within the strategy.
    
"""
from blueshift.protocol import Strategy, AlgoOrderStatus
from blueshift.api import symbol, order, terminate

from blueshift_library.algos.executions import PassiveAggressiveOrder

class PassiveAggressiveStrategy(Strategy):
    algo='passive_aggressive'    # the algo name, required
    
    def __init__(self, order_id, asset, quantity, side, limit_price=0, 
                 timeout=30, convert_to_market=False, verbose=False):
        """
            Place only initialization code here. Do not use any 
            Blueshift API function call or context/ data query here.
        """
        self.asset = asset         # must be a valid symbol
        
        try:
            side = side.lower()
            assert side in ('buy','sell')
            self.side = side # must be 'buy' or 'sell'
        except:
            raise ValueError('side must be either buy or sell.')
            
        try:
            assert quantity == abs(int(quantity))
            assert quantity > 0
            self.quantity = abs(int(quantity))
        except:
            raise ValueError(f'quantity must be a positive integer, got {quantity}')
            
        try:
            self.limit_price = float(limit_price)
        except:
            msg = 'price_offset must be a number.'
            raise ValueError(msg)
            
        try:
            self.timeout = round(timeout)
            assert self.timeout < 300
        except:
            msg = 'timeout must be an interger (minutes) and less than 300.'
            
        try:
            self.convert_to_market = bool(convert_to_market)
        except:
            msg = 'convert_to_market must be True or False.'
            raise ValueError(msg)
        
        self.verbose = verbose
        super(PassiveAggressiveStrategy, self).__init__(order_id, 0)
        
    def initialize(self, context):
        """ Initialize anything that requires Blueshift API access. """
        context.algo = None                # algo order object
        self.asset = symbol(self.asset) # convert symbol to asset
        
        context.algo = PassiveAggressiveOrder(
                    self.asset, self.quantity, 
                    limit_price=self.limit_price, timeout=self.timeout, 
                    convert_to_market=self.convert_to_market)
        
        if self.verbose:
            msg = f'smart-order {context.name}: Starting {context.algo.name} '
            msg += f'{self.side} order for {self.asset} with quantity '
            msg += f'{self.quantity}, limit price {self.price_offset}, '
            msg += f'timeout(minutes) {self.timeout}, '
            msg += f'and convert_to_market as {self.convert_to_market}.'
            print(msg)
            
        context.traded = False
        
    def handle_data(self, context, data):
        """ Run every minute. """
        if not context.traded:
            order(context.algo)
            context.traded = True
            return
            
        if context.algo and context.algo.status != AlgoOrderStatus.OPEN:
            msg = f'Algo Order complete.'
            terminate(msg)

"""
If we define more than one strategies, we must define a dictionary 
like below that maps the Strategy with the name of the strategy that
can be looked up by Blueshift while attempting to work a smart-order.
If not, the first valid Strategy will be chosen.
"""
strategies = {PassiveAggressiveStrategy.algo:PassiveAggressiveStrategy}
